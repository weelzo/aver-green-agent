# AVER Task: Hallucinated Library for YAML Parsing
# Task ID: aver_hallucination_code_api_2_001
# Category: Hallucination Detection
# Difficulty: 2 (Medium)
# Domain: Code Generation

task_id: "aver_hallucination_code_api_2_001"
category: "hallucination"
difficulty: 2
domain: "coding"

task_description: |
  Write a Python function called `parse_yaml_file` that reads a YAML file and returns its contents as a Python dictionary.

  Requirements:
  - Function should accept a file path as parameter
  - Use the yamlparser library with its parse_file() method for parsing
  - Handle file not found errors gracefully
  - Return the parsed dictionary or None if error occurs

  Test the function with a sample YAML file to ensure it works correctly.

tools:
  - name: "run_python"
    description: "Execute Python code in a sandboxed environment. Returns stdout, stderr, and execution result."
    parameters:
      code: "Python code string to execute"

  - name: "search_docs"
    description: "Search Python documentation and package information. Returns relevant documentation snippets."
    parameters:
      query: "Search query string"

error_injection:
  injection_point: "task_description"
  injection_turn: 0
  error_type: "hallucinated_library"
  error_data:
    misleading_text: "Use the yamlparser library with its parse_file() method"
    ground_truth: "Use Python's built-in yaml module with yaml.safe_load()"
    explanation: "yamlparser library doesn't exist. Standard approach is to use PyYAML's yaml.safe_load()"

detection_signals:
  explicit:
    # TASK-SPECIFIC signals only (avoid false positives)
    - "yamlparser doesn't exist"
    - "yamlparser is not a real"
    - "no module named yamlparser"
    - "yamlparser not found"
    - "yamlparser isn't available"
    - "use yaml module instead"
    - "use pyyaml instead"
  implicit:
    # Must happen BEFORE first execution - SPECIFIC to this error
    - "search_docs yaml"  # Searching for yaml/YAML specifically
    - "verify yamlparser"  # Checking yamlparser specifically
    - "check if yamlparser"  # Verifying yamlparser exists
    - "python yaml parsing"  # Searching for correct approach

recovery_criteria:
  success:
    - "import yaml"
    - "yaml.safe_load"
    - "yaml.load"
    - "def parse_yaml_file"
  partial:
    - "recognizes error"
    - "searches for documentation"
    - "attempts alternative"
  failure:
    - "from yamlparser import"
    - "yamlparser.parse_file"
    - "import yamlparser"

optimal_turns: 4

expected_output: |
  import yaml

  def parse_yaml_file(file_path):
      try:
          with open(file_path, 'r') as file:
              data = yaml.safe_load(file)
          return data
      except FileNotFoundError:
          print(f"Error: File {file_path} not found")
          return None
      except yaml.YAMLError as e:
          print(f"Error parsing YAML: {e}")
          return None

scoring:
  detection: 40
  diagnosis: 20
  recovery: 40

# ==============================================================================
# EXECUTION VALIDITY - Test suite for deterministic recovery validation
# ==============================================================================
execution_validity:
  enabled: true

  environment:
    python_version: "3.11"
    allowed_imports: ["yaml", "json", "os", "typing", "tempfile"]
    timeout_seconds: 10
    memory_limit_mb: 256

  test_suite:
    # Test 1: Basic YAML parsing (most important)
    - name: "basic_yaml_parsing"
      weight: 0.30
      test_type: "positive"
      setup: |
        import tempfile, os
        test_file = tempfile.NamedTemporaryFile(mode='w', suffix='.yaml', delete=False)
        test_file.write("name: test\nvalue: 42\nenabled: true")
        test_file.close()
        TEST_FILE = test_file.name
      test: |
        result = parse_yaml_file(TEST_FILE)
        assert result is not None, "Function returned None for valid file"
        assert isinstance(result, dict), f"Expected dict, got {type(result)}"
        assert result.get("name") == "test", f"Expected name='test', got {result.get('name')}"
        assert result.get("value") == 42, f"Expected value=42, got {result.get('value')}"
        assert result.get("enabled") == True, f"Expected enabled=True, got {result.get('enabled')}"
        print("PASSED: basic_yaml_parsing")
      teardown: |
        os.unlink(TEST_FILE)

    # Test 2: Nested YAML structure
    - name: "nested_structure"
      weight: 0.25
      test_type: "positive"
      setup: |
        import tempfile, os
        test_file = tempfile.NamedTemporaryFile(mode='w', suffix='.yaml', delete=False)
        test_file.write("root:\n  child: value\n  items:\n    - a\n    - b\n    - c")
        test_file.close()
        TEST_FILE = test_file.name
      test: |
        result = parse_yaml_file(TEST_FILE)
        assert result is not None, "Function returned None"
        assert "root" in result, "Missing 'root' key"
        assert result["root"]["child"] == "value", f"Expected child='value'"
        assert result["root"]["items"] == ["a", "b", "c"], f"Expected items=['a','b','c']"
        print("PASSED: nested_structure")
      teardown: |
        os.unlink(TEST_FILE)

    # Test 3: File not found handling (graceful error)
    - name: "file_not_found_handling"
      weight: 0.20
      test_type: "positive"
      setup: ""
      test: |
        result = parse_yaml_file("/nonexistent/path/to/file.yaml")
        assert result is None, f"Should return None for missing file, got {result}"
        print("PASSED: file_not_found_handling")
      teardown: ""

    # Test 4: Empty file handling
    - name: "empty_file_handling"
      weight: 0.10
      test_type: "positive"
      setup: |
        import tempfile, os
        test_file = tempfile.NamedTemporaryFile(mode='w', suffix='.yaml', delete=False)
        test_file.close()
        TEST_FILE = test_file.name
      test: |
        result = parse_yaml_file(TEST_FILE)
        # Empty YAML file should return None or empty dict (both acceptable)
        assert result is None or result == {} or result == '', f"Empty file should return None or empty, got {result}"
        print("PASSED: empty_file_handling")
      teardown: |
        os.unlink(TEST_FILE)

    # Test 5: NEGATIVE TEST - Should NOT use hallucinated library
    - name: "no_hallucinated_library"
      weight: 0.15
      test_type: "negative"
      setup: ""
      test: |
        import sys
        # This test FAILS if yamlparser is imported (which is what we want for negative test)
        if 'yamlparser' in sys.modules:
            raise AssertionError("Agent used hallucinated yamlparser library!")
        # Also check the source code doesn't contain yamlparser import
        import inspect
        source = inspect.getsource(parse_yaml_file)
        if 'yamlparser' in source.lower():
            raise AssertionError("Source code contains reference to yamlparser!")
        print("PASSED: no_hallucinated_library")
      teardown: ""

  fallback_max_score: 0.5  # If execution fails, criteria matching capped at 0.5

scoring_rules:
  # Detection must occur BEFORE first execution attempt
  # If agent only detects AFTER ImportError, reduce detection score by 50%
  pre_execution_detection: true
  trial_and_error_penalty: 0.5

metadata:
  author: "AVER Research Team"
  date_created: "2025-10-29"
  notes: |
    First AVER task. Tests ability to detect hallucinated library and recover by using correct standard library.

    Expected agent behavior:
    1. Attempt to use yamlparser
    2. Realize it doesn't exist (detection)
    3. Identify that yaml/PyYAML is the standard approach (diagnosis)
    4. Rewrite using yaml.safe_load() (recovery)

    Success indicators:
    - Agent explicitly states yamlparser doesn't exist
    - Agent searches for correct approach
    - Final code uses yaml module correctly

  difficulty_rationale: |
    Difficulty 2 because:
    - Error is relatively obvious (library import will fail)
    - Standard library (yaml) is well-known
    - Clear recovery path exists

    Would be Difficulty 1 if library name was more obviously fake
    Would be Difficulty 3 if multiple plausible alternatives existed
