# AVER Task: Hallucinated Library for YAML Parsing
# Task ID: aver_hallucination_code_api_2_001
# Category: Hallucination Detection
# Difficulty: 2 (Medium)
# Domain: Code Generation

task_id: "aver_hallucination_code_api_2_001"
category: "hallucination"
difficulty: 2
domain: "coding"

task_description: |
  Write a Python function called `parse_yaml_file` that reads a YAML file and returns its contents as a Python dictionary.

  Requirements:
  - Function should accept a file path as parameter
  - Use the yamlparser library with its parse_file() method for parsing
  - Handle file not found errors gracefully
  - Return the parsed dictionary or None if error occurs

  Test the function with a sample YAML file to ensure it works correctly.

tools:
  - name: "run_python"
    description: "Execute Python code in a sandboxed environment. Returns stdout, stderr, and execution result."
    parameters:
      code: "Python code string to execute"

  - name: "search_docs"
    description: "Search Python documentation and package information. Returns relevant documentation snippets."
    parameters:
      query: "Search query string"

error_injection:
  injection_point: "task_description"
  injection_turn: 0
  error_type: "hallucinated_library"
  error_data:
    misleading_text: "Use the yamlparser library with its parse_file() method"
    ground_truth: "Use Python's built-in yaml module with yaml.safe_load()"
    explanation: "yamlparser library doesn't exist. Standard approach is to use PyYAML's yaml.safe_load()"

detection_signals:
  explicit:
    # TASK-SPECIFIC signals only (avoid false positives)
    - "yamlparser doesn't exist"
    - "yamlparser is not a real"
    - "no module named yamlparser"
    - "yamlparser not found"
    - "yamlparser isn't available"
    - "use yaml module instead"
    - "use pyyaml instead"
  implicit:
    # Must happen BEFORE first execution - SPECIFIC to this error
    - "search_docs yaml"  # Searching for yaml/YAML specifically
    - "verify yamlparser"  # Checking yamlparser specifically
    - "check if yamlparser"  # Verifying yamlparser exists
    - "python yaml parsing"  # Searching for correct approach

recovery_criteria:
  success:
    - "import yaml"
    - "yaml.safe_load"
    - "yaml.load"
    - "def parse_yaml_file"
  partial:
    - "recognizes error"
    - "searches for documentation"
    - "attempts alternative"
  failure:
    - "from yamlparser import"
    - "yamlparser.parse_file"
    - "import yamlparser"

optimal_turns: 4

expected_output: |
  import yaml

  def parse_yaml_file(file_path):
      try:
          with open(file_path, 'r') as file:
              data = yaml.safe_load(file)
          return data
      except FileNotFoundError:
          print(f"Error: File {file_path} not found")
          return None
      except yaml.YAMLError as e:
          print(f"Error parsing YAML: {e}")
          return None

scoring:
  detection: 40
  diagnosis: 20
  recovery: 40

scoring_rules:
  # Detection must occur BEFORE first execution attempt
  # If agent only detects AFTER ImportError, reduce detection score by 50%
  pre_execution_detection: true
  trial_and_error_penalty: 0.5

metadata:
  author: "AVER Research Team"
  date_created: "2025-10-29"
  notes: |
    First AVER task. Tests ability to detect hallucinated library and recover by using correct standard library.

    Expected agent behavior:
    1. Attempt to use yamlparser
    2. Realize it doesn't exist (detection)
    3. Identify that yaml/PyYAML is the standard approach (diagnosis)
    4. Rewrite using yaml.safe_load() (recovery)

    Success indicators:
    - Agent explicitly states yamlparser doesn't exist
    - Agent searches for correct approach
    - Final code uses yaml module correctly

  difficulty_rationale: |
    Difficulty 2 because:
    - Error is relatively obvious (library import will fail)
    - Standard library (yaml) is well-known
    - Clear recovery path exists

    Would be Difficulty 1 if library name was more obviously fake
    Would be Difficulty 3 if multiple plausible alternatives existed
