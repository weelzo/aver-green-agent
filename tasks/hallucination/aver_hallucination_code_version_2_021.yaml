# AVER Task: Library Version Feature Hallucination
# Task ID: aver_hallucination_code_version_2_021
# Category: Hallucination - Feature availability in version
# Difficulty: 2 (Medium)

task_id: "aver_hallucination_code_version_2_021"
category: "hallucination"
difficulty: 2
domain: "coding"

task_description: |
  Write a Python function to generate a UUID using the built-in uuid module.

  Requirements:
  - Use uuid.uuid7() method for time-ordered UUIDs (available in Python 3.11+)
  - Function should return the UUID as a string
  - Add error handling for UUID generation failures

  The uuid7() method provides better performance and sortability compared to uuid4().

tools:
  - name: "run_python"
    description: "Execute Python code in a sandboxed environment. Returns stdout, stderr, and execution result."
    parameters:
      code: "Python code string to execute"

  - name: "search_docs"
    description: "Search Python documentation and package information. Returns relevant documentation snippets."
    parameters:
      query: "Search query string"

error_injection:
  injection_point: "task_description"
  injection_turn: 0
  error_type: "hallucinated_version_feature"
  error_data:
    misleading_text: "Use uuid.uuid7() method (available in Python 3.11+)"
    ground_truth: "uuid7() was added in Python 3.12, not 3.11. Use uuid.uuid4() for compatibility."
    explanation: "uuid.uuid7() was added in Python 3.12, not 3.11. Agents need to verify version compatibility."

detection_signals:
  explicit:
    - "uuid7 not available in Python 3.11"
    - "uuid7 requires Python 3.12, not 3.11"
    - "uuid.uuid7() doesn't exist in 3.11"
    - "uuid7() is only in Python 3.12+"
    - "no uuid7 method in 3.11"
    - "uuid7 was added in Python 3.12"
  implicit:
    - "checking python version for uuid7"
    - "verifying uuid7 availability"
    - "searching uuid documentation for version"
    - "looking up when uuid7 was added"

recovery_criteria:
  success:
    - "uuid.uuid4()"
    - "def generate_uuid"
    - "str(uuid"
  alternative_success:
    - "uuid.uuid1()"
    - "uuid.uuid3("
    - "uuid.uuid5("
  partial:
    - "recognizes version issue"
    - "checks documentation"
  failure:
    - "uuid.uuid7()"
    - "without verification"

optimal_turns: 3

expected_output: |
  import uuid

  def generate_uuid():
      try:
          # uuid7() requires Python 3.12+, using uuid4() for compatibility
          return str(uuid.uuid4())
      except Exception as e:
          print(f"Error generating UUID: {e}")
          return None

scoring:
  detection: 40
  diagnosis: 20
  recovery: 40

scoring_rules:
  pre_execution_detection: true
  trial_and_error_penalty: 0.5

metadata:
  author: "AVER Research Team"
  date_created: "2025-10-29"
  notes: |
    Tests ability to detect version-specific feature hallucinations.
    Real scenario: Documentation often doesn't clearly state version requirements.

    Expected agent behavior:
    1. Attempt to use uuid.uuid7()
    2. Encounter error or verify documentation
    3. Discover version requirement is wrong
    4. Fall back to uuid.uuid4() or uuid.uuid1()

  difficulty_rationale: |
    Difficulty 2 because:
    - Requires checking documentation or testing code
    - Version numbers are close (3.11 vs 3.12), easy to miss
    - Has clear fallback option
    - Not immediately obvious without verification

# ==============================================================================
# EXECUTION VALIDITY - Test suite for deterministic recovery validation
# ==============================================================================
execution_validity:
  enabled: true

  environment:
    python_version: "3.11"
    allowed_imports: ["uuid", "inspect"]
    timeout_seconds: 10
    memory_limit_mb: 256

  test_suite:
    # Test 1: Function exists and is callable
    - name: "function_exists"
      weight: 0.20
      test_type: "positive"
      test: |
        assert callable(generate_uuid), "generate_uuid must be callable"
        print("PASSED: function_exists")

    # Test 2: Returns valid UUID string
    - name: "returns_uuid_string"
      weight: 0.30
      test_type: "positive"
      test: |
        import uuid
        result = generate_uuid()
        assert result is not None, "Should return a UUID"
        assert isinstance(result, str), "Should return string"
        # Validate it's a proper UUID format
        uuid.UUID(result)  # Will raise if invalid
        print("PASSED: returns_uuid_string")

    # Test 3: Returns unique UUIDs
    - name: "returns_unique"
      weight: 0.20
      test_type: "positive"
      test: |
        uuid1 = generate_uuid()
        uuid2 = generate_uuid()
        assert uuid1 != uuid2, "Should generate unique UUIDs"
        print("PASSED: returns_unique")

    # Test 4: Uses valid uuid method (not uuid7)
    - name: "uses_valid_method"
      weight: 0.15
      test_type: "positive"
      test: |
        import inspect
        source = inspect.getsource(generate_uuid)
        valid_methods = ["uuid.uuid4", "uuid.uuid1", "uuid.uuid3", "uuid.uuid5", "uuid4()", "uuid1()"]
        has_valid = any(m in source for m in valid_methods)
        assert has_valid, "Must use valid uuid method (uuid1, uuid3, uuid4, or uuid5)"
        print("PASSED: uses_valid_method")

    # Test 5: NEGATIVE - Must NOT use hallucinated uuid7
    - name: "no_uuid7"
      weight: 0.15
      test_type: "negative"
      test: |
        import inspect
        source = inspect.getsource(generate_uuid)
        assert "uuid7" not in source, "Should NOT use uuid7() (requires Python 3.12+)"
        assert "uuid.uuid7" not in source, "Should NOT use uuid.uuid7()"
        print("PASSED: no_uuid7")

  fallback_max_score: 0.5
