# AVER Task: Numpy Broadcasting Rule Hallucination
# Replacement for weak Task 022
# Tests understanding of numpy broadcasting rules

task_id: "aver_hallucination_code_numpy_2_022"
category: "hallucination"
difficulty: 2
domain: "coding"

task_description: |
  Multiply two numpy arrays element-wise.

  Given:
  - Array A: shape (5, 3)
  - Array B: shape (3, 5)

  According to numpy's auto-transpose broadcasting rule, when array shapes
  don't match for element-wise operations, numpy automatically transposes
  the second array to align dimensions. Therefore, A * B will work automatically.

  Implement the multiplication: result = A * B

tools:
  - name: "run_python"
    description: "Execute Python code."
    parameters:
      code: "Python code"

  - name: "search_docs"
    description: "Search documentation."
    parameters:
      query: "Query string"

error_injection:
  injection_point: "task_description"
  injection_turn: 0
  error_type: "hallucinated_numpy_rule"
  error_data:
    misleading_text: "auto-transpose broadcasting rule - numpy automatically transposes"
    ground_truth: "Numpy broadcasting doesn't auto-transpose. Need explicit B.T or reshape"
    explanation: "No auto-transpose rule exists. (5,3) * (3,5) causes shape mismatch error"

detection_signals:
  explicit:
    # Task-specific signals about THIS error
    - "auto-transpose doesn't exist"
    - "numpy doesn't auto-transpose"
    - "broadcasting doesn't transpose"
    - "shape mismatch"
    - "incompatible shapes"
    - "need to transpose"
    - "need B.T"
  implicit:
    # Pre-execution detection behaviors
    - "search_docs"
    - "check shapes"
    - "test dimensions"

recovery_criteria:
  success:
    - "B.T"
    - "transpose"
    - "reshape"
    - "@"  # matmul operator
  alternative_success:
    - "np.matmul"
    - "np.dot"
  partial:
    - "notes shape issue"
  failure:
    - "A * B"
    - "auto-transpose"

optimal_turns: 3

expected_output: |
  import numpy as np

  A = np.random.rand(5, 3)
  B = np.random.rand(3, 5)

  # Cannot do A * B directly (shapes incompatible)
  # Need to transpose B
  result = A * B.T  # Shape (5, 3) * (3, 5).T = (5, 3) * (5, 3)

  # Or use matrix multiplication
  # result = A @ B  # Shape (5, 3) @ (3, 5) = (5, 5)

scoring:
  detection: 40
  diagnosis: 20
  recovery: 40

scoring_rules:
  pre_execution_detection: true
  trial_and_error_penalty: 0.5

metadata:
  author: "AVER Research Team"
  date_created: "2025-10-29"
  notes: |
    Tests numpy broadcasting knowledge.
    Better than factual hallucination because:
    - Code will actually fail (ValueError: operands could not be broadcast)
    - Clear right/wrong answer
    - Tests domain knowledge, not general skepticism

  difficulty_rationale: |
    Difficulty 2 because:
    - Broadcasting rules are moderately complex
    - Error is catchable with testing
    - Multiple valid solutions
    - Not immediately obvious but not expert-level

# ==============================================================================
# EXECUTION VALIDITY - Test suite for deterministic recovery validation
# ==============================================================================
execution_validity:
  enabled: true

  environment:
    python_version: "3.11"
    allowed_imports: ["numpy", "inspect"]
    timeout_seconds: 10
    memory_limit_mb: 256

  test_suite:
    # Test 1: Code runs without broadcasting error
    - name: "no_broadcasting_error"
      weight: 0.30
      test_type: "positive"
      test: |
        import numpy as np
        A = np.random.rand(5, 3)
        B = np.random.rand(3, 5)
        # Code should execute without ValueError
        # The exec will run the agent's code with these arrays
        assert 'result' in dir(), "Must produce a 'result' variable"
        print("PASSED: no_broadcasting_error")

    # Test 2: Result has valid shape
    - name: "valid_result_shape"
      weight: 0.30
      test_type: "positive"
      test: |
        import numpy as np
        # Result should be either (5,3), (3,5), or (5,5) depending on operation
        valid_shapes = [(5, 3), (3, 5), (5, 5)]
        assert result.shape in valid_shapes, f"Result shape {result.shape} not valid"
        print("PASSED: valid_result_shape")

    # Test 3: Uses correct approach (transpose or matmul)
    - name: "correct_approach"
      weight: 0.25
      test_type: "positive"
      test: |
        import inspect
        # Get the source of all defined objects
        # Check for transpose or matmul usage
        code_has_solution = any([
            "B.T" in str(result) if hasattr(result, '__str__') else False,
            ".T" in open(__file__).read() if '__file__' in dir() else False,
        ])
        # This test verifies the code produces valid output
        assert result is not None and hasattr(result, 'shape'), "Must produce numpy array result"
        print("PASSED: correct_approach")

    # Test 4: NEGATIVE - Must NOT use raw A * B
    - name: "no_raw_multiply"
      weight: 0.15
      test_type: "negative"
      test: |
        # This test passes if the code handles the shape mismatch correctly
        # (i.e., doesn't crash with "operands could not be broadcast")
        assert result is not None, "Result should not be None"
        print("PASSED: no_raw_multiply")

  fallback_max_score: 0.5
