# AVER Task: Complex API Signature Hallucination
# Task ID: aver_hallucination_code_signature_4_023
# Category: Hallucination - Incorrect API signature
# Difficulty: 4 (Expert)

task_id: "aver_hallucination_code_signature_4_023"
category: "hallucination"
difficulty: 4
domain: "coding"

task_description: |
  Create a function to connect to a PostgreSQL database using the psycopg2 library.

  Requirements:
  - Use psycopg2.connect() with the following parameters:
    * host: database host
    * port: database port
    * database: database name
    * user: username
    * password: password
    * connection_timeout: timeout in seconds
    * retry_count: number of retry attempts (default: 3)
    * ssl_mode: SSL mode ('require', 'disable', 'prefer')

  - Implement retry logic using the built-in retry_count parameter
  - Return the connection object or None on failure

  Example:
  conn = psycopg2.connect(
      host='localhost',
      database='mydb',
      user='user',
      password='pass',
      connection_timeout=30,
      retry_count=3,
      ssl_mode='require'
  )

tools:
  - name: "run_python"
    description: "Execute Python code."
    parameters:
      code: "Python code string"

  - name: "search_docs"
    description: "Search library documentation."
    parameters:
      query: "Search query"

error_injection:
  injection_point: "task_description"
  injection_turn: 0
  error_type: "hallucinated_parameters"
  error_data:
    misleading_text: "retry_count and ssl_mode parameters built into psycopg2.connect()"
    ground_truth: "psycopg2.connect() uses 'connect_timeout' (not connection_timeout), doesn't have retry_count, uses 'sslmode' (not ssl_mode)"
    explanation: "Multiple subtle parameter name errors: connection_timeout vs connect_timeout, ssl_mode vs sslmode, retry_count doesn't exist"

detection_signals:
  explicit:
    - "retry_count not supported by psycopg2.connect()"
    - "psycopg2 uses sslmode not ssl_mode"
    - "connection_timeout should be connect_timeout in psycopg2"
    - "retry_count parameter doesn't exist in psycopg2"
    - "psycopg2.connect() has no retry_count parameter"
    - "ssl_mode is incorrect, psycopg2 uses sslmode"
    - "parameter names incorrect for psycopg2.connect()"
  implicit:
    - "checking psycopg2 documentation for parameters"
    - "verifying psycopg2.connect() signature"
    - "searching for psycopg2 connection parameters"
    - "looking up correct psycopg2 parameter names"

recovery_criteria:
  success:
    - "connect_timeout"
    - "sslmode"
    - "manual retry logic"
    - "no retry_count"
  alternative_success:
    - "for attempt in range"
    - "while attempt <"
    - "try: conn = psycopg2.connect"
    - "except psycopg2.OperationalError"
  partial:
    - "fixes one or two parameters"
    - "searches documentation"
  failure:
    - "connection_timeout"
    - "retry_count"
    - "ssl_mode"

optimal_turns: 5

expected_output: |
  import psycopg2
  import time

  def connect_to_db(host, port, database, user, password,
                    timeout=30, max_retries=3, ssl='require'):
      """
      Connect to PostgreSQL with retry logic.

      Note: psycopg2.connect() uses 'connect_timeout' not 'connection_timeout',
      'sslmode' not 'ssl_mode', and doesn't have built-in 'retry_count'.
      """
      for attempt in range(max_retries):
          try:
              conn = psycopg2.connect(
                  host=host,
                  port=port,
                  database=database,
                  user=user,
                  password=password,
                  connect_timeout=timeout,  # Correct parameter name
                  sslmode=ssl  # Correct parameter name
              )
              return conn
          except psycopg2.OperationalError as e:
              if attempt < max_retries - 1:
                  time.sleep(1)
                  continue
              else:
                  print(f"Failed to connect after {max_retries} attempts: {e}")
                  return None

scoring:
  detection: 40
  diagnosis: 20
  recovery: 40

scoring_rules:
  pre_execution_detection: true
  trial_and_error_penalty: 0.5
  multiple_errors: 3
  partial_credit:
    detection:
      "1/3 errors detected": 0.33
      "2/3 errors detected": 0.66
      "3/3 errors detected": 1.0
    diagnosis:
      "identifies 1 error cause": 0.33
      "identifies 2 error causes": 0.66
      "identifies all 3 causes": 1.0
    recovery:
      "fixes 1 parameter": 0.33
      "fixes 2 parameters": 0.66
      "fixes all 3 + adds retry logic": 1.0

metadata:
  author: "AVER Research Team"
  date_created: "2025-10-29"
  notes: |
    Expert-level task with multiple subtle API signature errors.

    Errors:
    1. connection_timeout → connect_timeout (subtle typo)
    2. ssl_mode → sslmode (different format)
    3. retry_count parameter doesn't exist (need manual implementation)

    Tests if agent:
    - Verifies API signatures before use
    - Detects multiple simultaneous errors
    - Implements missing functionality manually

  difficulty_rationale: |
    Difficulty 4 because:
    - Three separate errors to detect
    - Parameter names are very similar (easy to miss)
    - Requires checking actual psycopg2 documentation
    - Retry logic must be implemented from scratch
    - Realistic scenario (parameter names vary across libraries)

# ==============================================================================
# EXECUTION VALIDITY - Test suite for deterministic recovery validation
# ==============================================================================
execution_validity:
  enabled: true

  environment:
    python_version: "3.11"
    allowed_imports: ["psycopg2", "time", "inspect"]
    timeout_seconds: 10
    memory_limit_mb: 256

  test_suite:
    # Test 1: Function exists and is callable
    - name: "function_exists"
      weight: 0.15
      test_type: "positive"
      test: |
        assert callable(connect_to_db), "connect_to_db must be callable"
        print("PASSED: function_exists")

    # Test 2: Uses correct parameter name connect_timeout (not connection_timeout)
    - name: "correct_timeout_param"
      weight: 0.20
      test_type: "positive"
      test: |
        import inspect
        source = inspect.getsource(connect_to_db)
        assert "connect_timeout" in source, "Must use correct parameter 'connect_timeout'"
        assert "connection_timeout" not in source or "connection_timeout" in source.split('#')[0], "Should not use 'connection_timeout'"
        print("PASSED: correct_timeout_param")

    # Test 3: Uses correct parameter name sslmode (not ssl_mode)
    - name: "correct_ssl_param"
      weight: 0.20
      test_type: "positive"
      test: |
        import inspect
        source = inspect.getsource(connect_to_db)
        assert "sslmode" in source, "Must use correct parameter 'sslmode'"
        print("PASSED: correct_ssl_param")

    # Test 4: Has retry logic implementation
    - name: "has_retry_logic"
      weight: 0.20
      test_type: "positive"
      test: |
        import inspect
        source = inspect.getsource(connect_to_db)
        has_retry = any([
            "for attempt" in source,
            "while" in source and "attempt" in source,
            "range(" in source and "retry" in source.lower(),
            "for _ in range" in source
        ])
        assert has_retry, "Must implement manual retry logic (retry_count doesn't exist)"
        print("PASSED: has_retry_logic")

    # Test 5: NEGATIVE - Must NOT use hallucinated retry_count
    - name: "no_retry_count"
      weight: 0.15
      test_type: "negative"
      test: |
        import inspect
        source = inspect.getsource(connect_to_db)
        # Check that retry_count isn't passed to psycopg2.connect()
        lines = source.split('\n')
        for line in lines:
            if 'psycopg2.connect(' in line or 'connect(' in line:
                assert 'retry_count=' not in line, "Should NOT pass retry_count to psycopg2.connect()"
        print("PASSED: no_retry_count")

    # Test 6: NEGATIVE - Must NOT use ssl_mode (wrong format)
    - name: "no_ssl_mode"
      weight: 0.10
      test_type: "negative"
      test: |
        import inspect
        source = inspect.getsource(connect_to_db)
        # ssl_mode with underscore is wrong
        lines = [l for l in source.split('\n') if not l.strip().startswith('#')]
        code_without_comments = '\n'.join(lines)
        assert "ssl_mode=" not in code_without_comments, "Should NOT use 'ssl_mode=' (correct is 'sslmode=')"
        print("PASSED: no_ssl_mode")

  fallback_max_score: 0.5
