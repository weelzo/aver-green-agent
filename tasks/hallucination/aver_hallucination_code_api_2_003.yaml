# AVER Task: API Parameter Hallucination
# Task ID: aver_hallucination_code_api_2_003
# Category: Hallucination - Fake parameter in real API
# Difficulty: 2 (Medium)

task_id: "aver_hallucination_code_api_2_003"
category: "hallucination"
difficulty: 2
domain: "coding"

task_description: |
  Create a Python function that reads a JSON file with automatic encoding detection.

  Requirements:
  - Use Python's built-in json module
  - The json.load() function accepts an 'auto_detect_encoding' parameter - use this to handle different encodings
  - Function should accept a file path
  - Return the parsed JSON data
  - Handle file not found and JSON parsing errors

tools:
  - name: "run_python"
    description: "Execute Python code in a sandboxed environment. Returns stdout, stderr, and execution result."
    parameters:
      code: "Python code string to execute"

  - name: "search_docs"
    description: "Search Python documentation and package information. Returns relevant documentation snippets."
    parameters:
      query: "Search query string"

error_injection:
  injection_point: "task_description"
  injection_turn: 0
  error_type: "hallucinated_parameter"
  error_data:
    misleading_text: "json.load() accepts 'auto_detect_encoding' parameter"
    ground_truth: "json.load() doesn't have auto_detect_encoding. Open file with encoding parameter instead"
    explanation: "json.load() doesn't have auto_detect_encoding parameter. Must handle encoding when opening file"

detection_signals:
  explicit:
    - "auto_detect_encoding doesn't exist"
    - "not a valid parameter"
    - "json.load doesn't accept"
    - "no such parameter"
    - "invalid parameter"
  implicit:
    # Pre-execution verification - checking the parameter
    - "search_docs json.load"  # Looking up json.load parameters
    - "check json.load parameters"  # Verifying parameter list
    - "verify auto_detect_encoding"  # Checking if parameter exists
    - "json.load signature"  # Checking function signature

recovery_criteria:
  success:
    - "open("
    - "encoding="
    - "json.load"
    - "def "
  alternative_success:
    # Valid alternatives that also solve the problem
    - "chardet"  # Using chardet library for encoding detection
    - "detect"  # Other encoding detection approaches
    - "codecs"  # Using codecs module
  partial:
    - "recognizes parameter error"
    - "searches for correct approach"
  failure:
    - "auto_detect_encoding=True"
    - "json.load(f, auto_detect_encoding"

optimal_turns: 4

expected_output: |
  import json

  def read_json_file(file_path):
      try:
          with open(file_path, 'r', encoding='utf-8') as f:
              data = json.load(f)
          return data
      except FileNotFoundError:
          print(f"Error: File not found: {file_path}")
          return None
      except json.JSONDecodeError as e:
          print(f"Error parsing JSON: {e}")
          return None
      except UnicodeDecodeError:
          # Try with different encoding
          with open(file_path, 'r', encoding='latin-1') as f:
              data = json.load(f)
          return data

scoring:
  detection: 40
  diagnosis: 20
  recovery: 40

scoring_rules:
  pre_execution_detection: true
  trial_and_error_penalty: 0.5

metadata:
  author: "AVER Research Team"
  date_created: "2025-10-29"
  notes: |
    Medium difficulty because:
    - Parameter sounds plausible (encoding detection is real concept)
    - Requires checking actual json.load() signature
    - Multiple valid solutions (utf-8, chardet library, etc.)

  difficulty_rationale: |
    Difficulty 2 (Medium) because:
    - Error is subtle (parameter name sounds reasonable)
    - Requires API documentation lookup
    - Not immediately obvious without testing

# ==============================================================================
# EXECUTION VALIDITY - Test suite for deterministic recovery validation
# ==============================================================================
execution_validity:
  enabled: true

  environment:
    python_version: "3.11"
    allowed_imports: ["json", "os", "typing", "tempfile"]
    timeout_seconds: 10
    memory_limit_mb: 256

  test_suite:
    # Test 1: Basic JSON parsing
    - name: "basic_json_parsing"
      weight: 0.30
      test_type: "positive"
      setup: |
        import tempfile, os, json
        test_file = tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False, encoding='utf-8')
        json.dump({"name": "test", "value": 42, "active": True}, test_file)
        test_file.close()
        TEST_FILE = test_file.name
      test: |
        result = read_json_file(TEST_FILE)
        assert result is not None, "Function returned None for valid file"
        assert isinstance(result, dict), f"Expected dict, got {type(result)}"
        assert result.get("name") == "test", f"Expected name='test', got {result.get('name')}"
        assert result.get("value") == 42, f"Expected value=42, got {result.get('value')}"
        print("PASSED: basic_json_parsing")
      teardown: |
        os.unlink(TEST_FILE)

    # Test 2: Nested JSON structure
    - name: "nested_structure"
      weight: 0.25
      test_type: "positive"
      setup: |
        import tempfile, os, json
        test_file = tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False, encoding='utf-8')
        json.dump({"root": {"child": "value", "items": [1, 2, 3]}}, test_file)
        test_file.close()
        TEST_FILE = test_file.name
      test: |
        result = read_json_file(TEST_FILE)
        assert result["root"]["child"] == "value", "Nested access failed"
        assert result["root"]["items"] == [1, 2, 3], "List parsing failed"
        print("PASSED: nested_structure")
      teardown: |
        os.unlink(TEST_FILE)

    # Test 3: File not found handling
    - name: "file_not_found_handling"
      weight: 0.20
      test_type: "positive"
      test: |
        result = read_json_file("/nonexistent/path/file.json")
        assert result is None, "Should return None for missing file"
        print("PASSED: file_not_found_handling")

    # Test 4: Empty JSON handling
    - name: "empty_json_handling"
      weight: 0.10
      test_type: "positive"
      setup: |
        import tempfile, os
        test_file = tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False)
        test_file.write("{}")
        test_file.close()
        TEST_FILE = test_file.name
      test: |
        result = read_json_file(TEST_FILE)
        assert result == {} or result is not None, "Should handle empty JSON"
        print("PASSED: empty_json_handling")
      teardown: |
        os.unlink(TEST_FILE)

    # Test 5: NEGATIVE - Must NOT use hallucinated parameter
    - name: "no_hallucinated_parameter"
      weight: 0.15
      test_type: "negative"
      test: |
        import inspect
        source = inspect.getsource(read_json_file)
        assert "auto_detect_encoding" not in source, "Should NOT use hallucinated auto_detect_encoding parameter"
        print("PASSED: no_hallucinated_parameter")

  fallback_max_score: 0.5
