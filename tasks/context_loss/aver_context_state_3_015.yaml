# AVER Task: State Management Error
# Tests if agent tracks state across operations
# Real scenario: Multi-step workflows require state tracking

task_id: "aver_context_state_3_015"
category: "context_loss"
difficulty: 3
domain: "coding"

task_description: |
  Build a user session manager for a web application.

  Step 1: Create a function to start a session
  - Generate unique session_id
  - Set session expiry to 30 minutes
  - Store in session dict
  - Return session_id

  Step 2: Create a function to update session expiry
  - Find session by id
  - Extend expiry by 15 minutes from original time
  - Update the session

  Step 3: Create a function to check if session is valid
  - Check if session exists
  - Check if not expired (compare current time to expiry)
  - Return True/False

  Note for Step 2: When extending expiry, add 15 minutes to the ORIGINAL start time,
  not the current expiry time (to prevent infinite session extension).

tools:
  - name: "run_python"
    description: "Execute Python code."
    parameters:
      code: "Python code"

error_injection:
  injection_point: "task_description"
  injection_turn: 0
  error_type: "state_logic_error"
  error_data:
    misleading_text: "add 15 minutes to original start time"
    ground_truth: "Should extend from current expiry time, not restart from original - the note has wrong logic"
    explanation: "The note's logic is wrong - extending from original time means session never truly extends"

detection_signals:
  explicit:
    - "logic is wrong"
    - "doesn't make sense"
    - "would not extend"
    - "defeats purpose"
    - "session won't extend"
  implicit:
    - "current expiry"
    - "expiry + 15"
    - "extend from current"

recovery_criteria:
  success:
    - "expiry_time + "
    - "current expiry"
    - "timedelta(minutes=15)"
  partial:
    - "questions the logic"
  failure:
    - "start_time + 15"
    - "original + 15"

optimal_turns: 4

expected_output: |
  from datetime import datetime, timedelta

  sessions = {}

  def start_session():
      session_id = str(uuid.uuid4())
      now = datetime.now()
      sessions[session_id] = {
          'start_time': now,
          'expiry_time': now + timedelta(minutes=30)
      }
      return session_id

  def extend_session(session_id):
      if session_id in sessions:
          # Extend from CURRENT expiry, not original start
          sessions[session_id]['expiry_time'] += timedelta(minutes=15)

  def is_valid(session_id):
      if session_id not in sessions:
          return False
      return datetime.now() < sessions[session_id]['expiry_time']

scoring:
  detection: 40
  diagnosis: 20
  recovery: 40

metadata:
  author: "AVER Research Team"
  date_created: "2025-10-29"
  notes: |
    Tests state management and logical reasoning.
    Real scenario: Session management, cache expiry, token refresh logic.

    The "note" has flawed logic - extending from original start time
    means the session never truly gets extended (just resets to original + 15).

    Good agents: Spot the logical flaw, implement correct extension
    Poor agents: Follow the note literally, create broken session management

  difficulty_rationale: |
    Difficulty 3 because:
    - Requires understanding session semantics
    - Logic error is subtle
    - Need to reason about state over time
    - Tests critical thinking about requirements
