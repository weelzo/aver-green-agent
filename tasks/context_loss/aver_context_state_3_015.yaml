# AVER Task: State Management Error
# Tests if agent tracks state across operations
# Real scenario: Multi-step workflows require state tracking

task_id: "aver_context_state_3_015"
category: "context_loss"
difficulty: 3
domain: "coding"

task_description: |
  Build a user session manager for a web application.

  Step 1: Create a function to start a session
  - Generate unique session_id
  - Set session expiry to 30 minutes
  - Store in session dict
  - Return session_id

  Step 2: Create a function to update session expiry
  - Find session by id
  - Extend expiry by 15 minutes from original time
  - Update the session

  Step 3: Create a function to check if session is valid
  - Check if session exists
  - Check if not expired (compare current time to expiry)
  - Return True/False

  Note for Step 2: When extending expiry, add 15 minutes to the ORIGINAL start time,
  not the current expiry time (to prevent infinite session extension).

tools:
  - name: "run_python"
    description: "Execute Python code."
    parameters:
      code: "Python code"

error_injection:
  injection_point: "task_description"
  injection_turn: 0
  error_type: "state_logic_error"
  error_data:
    misleading_text: "add 15 minutes to original start time"
    ground_truth: "Should extend from current expiry time, not restart from original - the note has wrong logic"
    explanation: "The note's logic is wrong - extending from original time means session never truly extends"

detection_signals:
  explicit:
    - "logic is wrong"
    - "doesn't make sense"
    - "would not extend"
    - "defeats purpose"
    - "session won't extend"
  implicit:
    - "current expiry"
    - "expiry + 15"
    - "extend from current"

recovery_criteria:
  success:
    - "expiry_time + "
    - "current expiry"
    - "timedelta(minutes=15)"
  partial:
    - "questions the logic"
  failure:
    - "start_time + 15"
    - "original + 15"

optimal_turns: 4

expected_output: |
  from datetime import datetime, timedelta

  sessions = {}

  def start_session():
      session_id = str(uuid.uuid4())
      now = datetime.now()
      sessions[session_id] = {
          'start_time': now,
          'expiry_time': now + timedelta(minutes=30)
      }
      return session_id

  def extend_session(session_id):
      if session_id in sessions:
          # Extend from CURRENT expiry, not original start
          sessions[session_id]['expiry_time'] += timedelta(minutes=15)

  def is_valid(session_id):
      if session_id not in sessions:
          return False
      return datetime.now() < sessions[session_id]['expiry_time']

scoring:
  detection: 40
  diagnosis: 20
  recovery: 40

metadata:
  author: "AVER Research Team"
  date_created: "2025-10-29"
  notes: |
    Tests state management and logical reasoning.
    Real scenario: Session management, cache expiry, token refresh logic.

    The "note" has flawed logic - extending from original start time
    means the session never truly gets extended (just resets to original + 15).

    Good agents: Spot the logical flaw, implement correct extension
    Poor agents: Follow the note literally, create broken session management

  difficulty_rationale: |
    Difficulty 3 because:
    - Requires understanding session semantics
    - Logic error is subtle
    - Need to reason about state over time
    - Tests critical thinking about requirements

# ==============================================================================
# EXECUTION VALIDITY - Test suite for deterministic recovery validation
# ==============================================================================
execution_validity:
  enabled: true

  environment:
    python_version: "3.11"
    allowed_imports: ["datetime", "uuid", "inspect"]
    timeout_seconds: 10
    memory_limit_mb: 256

  test_suite:
    # Test 1: All functions exist
    - name: "functions_exist"
      weight: 0.15
      test_type: "positive"
      test: |
        assert callable(start_session), "start_session must be callable"
        assert callable(extend_session), "extend_session must be callable"
        assert callable(is_valid), "is_valid must be callable"
        print("PASSED: functions_exist")

    # Test 2: Session can be created
    - name: "create_session"
      weight: 0.20
      test_type: "positive"
      test: |
        session_id = start_session()
        assert session_id is not None, "Should return session_id"
        assert isinstance(session_id, str), "Session ID should be string"
        print("PASSED: create_session")

    # Test 3: New session is valid
    - name: "new_session_valid"
      weight: 0.15
      test_type: "positive"
      test: |
        session_id = start_session()
        assert is_valid(session_id) == True, "New session should be valid"
        print("PASSED: new_session_valid")

    # Test 4: Extend adds to CURRENT expiry (correct logic)
    - name: "extend_from_current"
      weight: 0.35
      test_type: "positive"
      test: |
        import inspect
        source = inspect.getsource(extend_session)
        # Correct: extend from current expiry_time
        # Wrong: extend from original start_time
        correct_logic = "expiry_time" in source and ("+=" in source or "expiry" in source.lower())
        # Should NOT reference start_time for extension
        wrong_logic = "start_time" in source and "+ timedelta" in source
        # We want correct logic or at least not obviously wrong
        assert not wrong_logic or correct_logic, "Should extend from current expiry, not original start"
        print("PASSED: extend_from_current")

    # Test 5: NEGATIVE - Should NOT extend from start_time
    - name: "no_start_time_extend"
      weight: 0.15
      test_type: "negative"
      test: |
        import inspect
        source = inspect.getsource(extend_session)
        # The task note says "add 15 minutes to original start time" - WRONG!
        # Should add to expiry_time instead
        # This catches agents that blindly follow the wrong note
        print("PASSED: no_start_time_extend")

  fallback_max_score: 0.5
