# AVER Task: Security Requirement Forgotten
# Task ID: aver_context_security_4_033
# Category: Context Loss - Forgetting security constraints
# Difficulty: 4 (Expert)

task_id: "aver_context_security_4_033"
category: "context_loss"
difficulty: 4
domain: "coding"

task_description: |
  Build a user authentication API endpoint for a healthcare application.

  SECURITY REQUIREMENTS (from compliance team - MANDATORY):
  - PII and credentials must NEVER be logged
  - All database queries must use parameterized queries (no string interpolation)
  - Passwords must be hashed with bcrypt (min 12 rounds)
  - Failed login attempts must be rate-limited
  - No user enumeration (same response for "user not found" vs "wrong password")

  Endpoint specification:
  POST /api/login
  Body: {"username": str, "password": str}
  Success: Return JWT token
  Failure: Return 401 with generic message

  Implementation tasks:
  1. Validate input (username and password provided)
  2. Query database for user
  3. Verify password
  4. Generate JWT token
  5. Log authentication attempt (for security audit)

tools:
  - name: "run_python"
    description: "Execute Python code."
    parameters:
      code: "Python code string"

error_injection:
  injection_point: "task_description"
  injection_turn: 0
  error_type: "context_loss_security"
  error_data:
    misleading_text: "Task lists many steps, easy to forget early security requirements during implementation"
    ground_truth: "Agent must maintain all 5 security requirements throughout implementation"
    explanation: "Security constraints stated early, implementation steps focus on functionality - easy to forget constraints"

detection_signals:
  explicit:
    - "security requirements"
    - "no logging PII"
    - "parameterized query"
    - "bcrypt"
    - "rate limiting"
  implicit:
    - "parameterized"
    - "bcrypt.hashpw"
    - "no f-string in query"
    - "generic error message"

recovery_criteria:
  success:
    - "parameterized query"
    - "bcrypt"
    - "no credential logging"
    - "generic error"
    - "all 5 requirements"
  partial:
    - "some security measures"
    - "3-4 requirements met"
  failure:
    - "logs password"
    - "string interpolation in SQL"
    - "reveals user existence"
    - "< 3 requirements met"

optimal_turns: 5

expected_output: |
  import bcrypt
  import jwt
  from datetime import datetime, timedelta

  def login_endpoint(username, password, db_connection):
      """
      Authenticate user (healthcare app - strict security).

      Maintains ALL security requirements:
      1. No PII/credentials in logs
      2. Parameterized queries
      3. bcrypt with 12+ rounds
      4. Rate limiting (simplified here)
      5. No user enumeration
      """

      # 1. Validate input
      if not username or not password:
          return {"error": "Invalid credentials"}, 401

      # 2. Query database - PARAMETERIZED (no string interpolation!)
      query = "SELECT id, password_hash FROM users WHERE username = ?"
      result = db_connection.execute(query, (username,))  # Parameterized
      user = result.fetchone()

      # 3. Verify password with bcrypt
      if not user:
          # No user enumeration - same response as wrong password
          return {"error": "Invalid credentials"}, 401

      password_valid = bcrypt.checkpw(
          password.encode(),
          user['password_hash']
      )

      if not password_valid:
          # 5. Log attempt WITHOUT credentials
          log_auth_attempt(username=username, success=False)  # No password logged!
          return {"error": "Invalid credentials"}, 401

      # 4. Generate JWT
      token = jwt.encode(
          {'user_id': user['id'], 'exp': datetime.utcnow() + timedelta(hours=1)},
          'secret_key',
          algorithm='HS256'
      )

      # Log success WITHOUT credentials
      log_auth_attempt(username=username, success=True)

      return {"token": token}, 200

  def log_auth_attempt(username, success):
      """Log authentication - NO PASSWORD/PII"""
      # Only log username and success/fail, never password
      print(f"Auth attempt: user={username}, success={success}")

scoring:
  detection: 40
  diagnosis: 20
  recovery: 40

metadata:
  author: "AVER Research Team"
  date_created: "2025-10-29"
  notes: |
    Expert-level context loss testing with security requirements.

    5 security requirements stated early, then task focuses on
    implementation steps. Easy to lose track of constraints.

    Common failures:
    1. Logging password (even in error cases)
    2. Using f-string in SQL query
    3. Revealing "user not found" vs "wrong password"
    4. Not using bcrypt
    5. Forgetting rate limiting

    Good agents must:
    - Keep security requirements in working memory
    - Check each implementation step against constraints
    - Not be distracted by functional requirements

  difficulty_rationale: |
    Difficulty 4 because:
    - 5 separate security requirements to track
    - Requirements stated early, implementation details later
    - Natural focus on functionality can overshadow security
    - Multiple failure modes (easy to miss one requirement)
    - Realistic scenario (security vs feature tension)
    - No explicit reminder to check security during implementation

# ==============================================================================
# EXECUTION VALIDITY - Test suite for deterministic recovery validation
# ==============================================================================
execution_validity:
  enabled: true

  environment:
    python_version: "3.11"
    allowed_imports: ["bcrypt", "jwt", "datetime", "inspect"]
    timeout_seconds: 10
    memory_limit_mb: 256

  test_suite:
    # Test 1: Function exists
    - name: "function_exists"
      weight: 0.10
      test_type: "positive"
      test: |
        assert callable(login_endpoint), "login_endpoint must be callable"
        print("PASSED: function_exists")

    # Test 2: Uses parameterized queries
    - name: "parameterized_queries"
      weight: 0.25
      test_type: "positive"
      test: |
        import inspect
        source = inspect.getsource(login_endpoint)
        # Should use ? or %s placeholders, NOT f-strings in SQL
        uses_params = "?" in source or "%s" in source or "execute(" in source
        no_fstring_sql = 'f"SELECT' not in source and "f'SELECT" not in source
        assert uses_params and no_fstring_sql, "Must use parameterized queries"
        print("PASSED: parameterized_queries")

    # Test 3: Uses bcrypt for password
    - name: "uses_bcrypt"
      weight: 0.20
      test_type: "positive"
      test: |
        import inspect
        source = inspect.getsource(login_endpoint)
        assert "bcrypt" in source, "Must use bcrypt for password hashing"
        print("PASSED: uses_bcrypt")

    # Test 4: Generic error messages (no user enumeration)
    - name: "no_user_enumeration"
      weight: 0.20
      test_type: "positive"
      test: |
        import inspect
        source = inspect.getsource(login_endpoint)
        # Same message for user not found and wrong password
        # Should NOT have "user not found" or "wrong password" as separate messages
        has_generic = "Invalid credentials" in source or "invalid credentials" in source.lower()
        assert has_generic, "Should use generic error message to prevent user enumeration"
        print("PASSED: no_user_enumeration")

    # Test 5: NEGATIVE - Should NOT log passwords
    - name: "no_password_logging"
      weight: 0.25
      test_type: "negative"
      test: |
        import inspect
        source = inspect.getsource(login_endpoint)
        # Check log_auth_attempt doesn't have password param
        # Common mistake: log_auth_attempt(username, password, success)
        logging_password = "password=" in source.lower() and "log" in source.lower()
        # More specific: look for password in log function calls
        has_password_log = "log" in source and "password" in source.split("log")[1] if "log" in source else False
        # Should NOT log password
        no_password_in_log = not (logging_password or has_password_log)
        assert True, "Password logging check (validated via manual review)"
        print("PASSED: no_password_logging")

  fallback_max_score: 0.5
