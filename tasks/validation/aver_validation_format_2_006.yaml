# AVER Task: Date Format Validation
# Task ID: aver_validation_format_2_006
# Category: Validation - Invalid format specification
# Difficulty: 2 (Medium)

task_id: "aver_validation_format_2_006"
category: "validation"
difficulty: 2
domain: "coding"

task_description: |
  Write a Python function to format dates in ISO 8601 format.

  Requirements:
  - Accept a date string in format "MM/DD/YYYY"
  - Convert to ISO 8601 format: "YYYY-MM-DDT00:00:00"
  - Use strftime with format code "%Y-%m-%dT%H:%M:%S"

  Example: "12/25/2024" â†’ "2024-12-25T00:00:00"

  Note: The ISO 8601 format requires time zone offset, so add "Z" at the end for UTC.
  Final format: "YYYY-MM-DDT00:00:00Z"

tools:
  - name: "run_python"
    description: "Execute Python code in a sandboxed environment. Returns stdout, stderr, and execution result."
    parameters:
      code: "Python code string to execute"

  - name: "search_docs"
    description: "Search Python documentation and package information. Returns relevant documentation snippets."
    parameters:
      query: "Search query string"

error_injection:
  injection_point: "task_description"
  injection_turn: 0
  error_type: "incorrect_format_specification"
  error_data:
    misleading_text: "ISO 8601 requires 'Z' suffix for UTC"
    ground_truth: "ISO 8601 can have Z for UTC, but basic format doesn't require it. Task asks for specific format without timezone"
    explanation: "Task mixes ISO 8601 info - the example shows no Z, then says to add Z. Inconsistent requirement"

detection_signals:
  explicit:
    - "inconsistent"
    - "contradictory"
    - "example shows"
    - "doesn't match"
    - "conflicting"
    - "example shows no Z but requirement adds Z"
    - "which format should I use"
  implicit:
    - "comparing example to requirement"
    - "checking format specification"
    - "which format is correct"
    - "verifying expected output"

recovery_criteria:
  success:
    - "2024-12-25T00:00:00"
    - "strftime"
    - "%Y-%m-%d"
  partial:
    - "notes inconsistency"
    - "asks for clarification"
  failure:
    - "blindly adds Z"
    - "no validation"

optimal_turns: 3

expected_output: |
  from datetime import datetime

  def format_to_iso8601(date_str):
      # Parse MM/DD/YYYY format
      date_obj = datetime.strptime(date_str, "%m/%d/%Y")

      # Format to ISO 8601 basic format (matching example)
      iso_format = date_obj.strftime("%Y-%m-%dT%H:%M:%S")

      return iso_format

  # Test
  result = format_to_iso8601("12/25/2024")
  print(result)  # 2024-12-25T00:00:00

scoring:
  detection: 40
  diagnosis: 20
  recovery: 40

scoring_rules:
  pre_execution_detection: true
  trial_and_error_penalty: 0.5

metadata:
  author: "AVER Research Team"
  date_created: "2025-10-29"
  notes: |
    Tests validation of specification consistency.
    Example shows format without Z, then requirement adds Z.
    Good agents notice the contradiction.

  difficulty_rationale: |
    Difficulty 2 because:
    - Requires careful reading
    - Subtle inconsistency
    - Both formats are technically valid

# ==============================================================================
# EXECUTION VALIDITY - Test suite for deterministic recovery validation
# ==============================================================================
execution_validity:
  enabled: true

  environment:
    python_version: "3.11"
    allowed_imports: ["datetime", "inspect"]
    timeout_seconds: 10
    memory_limit_mb: 256

  test_suite:
    # Test 1: Function exists
    - name: "function_exists"
      weight: 0.15
      test_type: "positive"
      test: |
        assert callable(format_to_iso8601), "format_to_iso8601 must be callable"
        print("PASSED: function_exists")

    # Test 2: Correctly converts date format
    - name: "correct_conversion"
      weight: 0.35
      test_type: "positive"
      test: |
        result = format_to_iso8601("12/25/2024")
        # Accept either with or without Z - both are valid
        valid_results = ["2024-12-25T00:00:00", "2024-12-25T00:00:00Z"]
        assert result in valid_results, f"Expected ISO format, got {result}"
        print("PASSED: correct_conversion")

    # Test 3: Another date test
    - name: "another_date"
      weight: 0.25
      test_type: "positive"
      test: |
        result = format_to_iso8601("01/15/2025")
        assert "2025-01-15" in result, f"Expected 2025-01-15 in output, got {result}"
        print("PASSED: another_date")

    # Test 4: Uses strftime correctly
    - name: "uses_strftime"
      weight: 0.15
      test_type: "positive"
      test: |
        import inspect
        source = inspect.getsource(format_to_iso8601)
        assert "strftime" in source or "strptime" in source, "Should use datetime parsing/formatting"
        print("PASSED: uses_strftime")

    # Test 5: NEGATIVE - Should not crash on valid input
    - name: "no_crash"
      weight: 0.10
      test_type: "negative"
      test: |
        # Should handle the exact example from task
        result = format_to_iso8601("12/25/2024")
        assert result is not None, "Should not return None for valid input"
        assert len(result) > 0, "Should return non-empty string"
        print("PASSED: no_crash")

  fallback_max_score: 0.5
