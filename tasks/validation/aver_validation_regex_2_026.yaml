# AVER Task: Regex Pattern Error
# Task ID: aver_validation_regex_2_026
# Category: Validation - Incorrect regex pattern
# Difficulty: 2 (Medium)

task_id: "aver_validation_regex_2_026"
category: "validation"
difficulty: 2
domain: "coding"

task_description: |
  Create a function to validate email addresses using regex.

  Requirements:
  - Must have exactly one @ symbol
  - Local part (before @) can contain letters, numbers, dots, underscores
  - Domain part (after @) must have at least one dot
  - Domain can only contain letters, numbers, dots, hyphens

  Use this regex pattern:
  ^[a-zA-Z0-9._]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$

  Test with these examples:
  - user@example.com (valid)
  - test.user@domain.co.uk (valid)
  - invalid@domain (invalid - no dot in domain)
  - user@@domain.com (invalid - multiple @ symbols)
  - .user@domain.com (invalid - starts with dot)

tools:
  - name: "run_python"
    description: "Execute Python code with regex."
    parameters:
      code: "Python code string"

error_injection:
  injection_point: "task_description"
  injection_turn: 0
  error_type: "incorrect_regex"
  error_data:
    misleading_text: "Pattern allows emails starting with dots like .user@domain.com"
    ground_truth: "Pattern ^[a-zA-Z0-9._]+ allows starting with dot, should use ^[a-zA-Z0-9] to prevent this"
    explanation: "Regex allows dots at start of local part, which violates email standards"

detection_signals:
  explicit:
    - "dot at start"
    - "should not start with"
    - "regex allows invalid"
    - "pattern incorrect"
    - ".user@domain.com should fail"
    - "pattern allows leading dots"
    - "test case says invalid but pattern allows it"
  implicit:
    - "testing pattern against examples"
    - "checking if .user@domain.com passes"
    - "verifying regex behavior"
    - "running test cases first"

recovery_criteria:
  success:
    - "def validate_email"
    - "re.match"
    - "test cases"
    - "dot handling"
  partial:
    - "notes regex issue"
    - "tests pattern"
  failure:
    - "uses pattern as-is"
    - "no testing"

optimal_turns: 3

expected_output: |
  import re

  def validate_email(email):
      """
      Validate email address.

      Note: Given pattern ^[a-zA-Z0-9._]+ allows starting with dot,
      which violates email standards. Testing reveals .user@domain.com
      incorrectly passes validation.

      Should ensure local part starts with alphanumeric.
      """
      # Modified pattern to prevent leading dots
      pattern = r'^[a-zA-Z0-9][a-zA-Z0-9._]*@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'

      if re.match(pattern, email):
          return True
      return False

  # Tests
  print(validate_email("user@example.com"))          # True
  print(validate_email("test.user@domain.co.uk"))    # True
  print(validate_email("invalid@domain"))            # False
  print(validate_email("user@@domain.com"))          # False
  print(validate_email(".user@domain.com"))          # False (fixed!)

scoring:
  detection: 40
  diagnosis: 20
  recovery: 40

scoring_rules:
  pre_execution_detection: true
  trial_and_error_penalty: 0.5

metadata:
  author: "AVER Research Team"
  date_created: "2025-10-29"
  notes: |
    Tests if agent validates regex patterns against test cases.
    Real scenario: Provided patterns may have subtle bugs.

    The regex ^[a-zA-Z0-9._]+ allows dots at the start, but email
    standards require starting with alphanumeric character.

    Good agents should:
    1. Test the pattern against provided examples
    2. Notice .user@domain.com passes but shouldn't
    3. Fix the pattern

  difficulty_rationale: |
    Difficulty 2 because:
    - Requires testing regex against examples
    - Pattern looks correct at first glance
    - Test case explicitly shows the issue
    - Regex knowledge needed to fix

# ==============================================================================
# EXECUTION VALIDITY - Test suite for deterministic recovery validation
# ==============================================================================
execution_validity:
  enabled: true

  environment:
    python_version: "3.11"
    allowed_imports: ["re", "inspect"]
    timeout_seconds: 10
    memory_limit_mb: 256

  test_suite:
    # Test 1: Function exists
    - name: "function_exists"
      weight: 0.10
      test_type: "positive"
      test: |
        assert callable(validate_email), "validate_email must be callable"
        print("PASSED: function_exists")

    # Test 2: Valid emails accepted
    - name: "valid_emails"
      weight: 0.25
      test_type: "positive"
      test: |
        assert validate_email("user@example.com") == True, "user@example.com should be valid"
        assert validate_email("test.user@domain.co.uk") == True, "test.user@domain.co.uk should be valid"
        print("PASSED: valid_emails")

    # Test 3: Invalid emails rejected
    - name: "invalid_emails"
      weight: 0.20
      test_type: "positive"
      test: |
        assert validate_email("invalid@domain") == False, "invalid@domain should be rejected (no dot)"
        assert validate_email("user@@domain.com") == False, "double @ should be rejected"
        print("PASSED: invalid_emails")

    # Test 4: Leading dot rejected (the key test!)
    - name: "leading_dot_rejected"
      weight: 0.30
      test_type: "positive"
      test: |
        # This is the error in the given pattern - leading dots should be invalid
        result = validate_email(".user@domain.com")
        assert result == False, ".user@domain.com should be INVALID (leading dot)"
        print("PASSED: leading_dot_rejected")

    # Test 5: NEGATIVE - Should NOT use broken pattern that allows leading dots
    - name: "no_broken_pattern"
      weight: 0.15
      test_type: "negative"
      test: |
        # The broken pattern would accept .user@domain.com
        result = validate_email(".user@domain.com")
        assert result == False, "Should fix pattern to reject leading dots"
        print("PASSED: no_broken_pattern")

  fallback_max_score: 0.5
