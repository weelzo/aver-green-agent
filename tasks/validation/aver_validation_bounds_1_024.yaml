# AVER Task: Simple Boundary Check Error
# Task ID: aver_validation_bounds_1_024
# Category: Validation - Boundary condition
# Difficulty: 1 (Easy)

task_id: "aver_validation_bounds_1_024"
category: "validation"
difficulty: 1
domain: "coding"

task_description: |
  Write a function to validate user age input.

  Requirements:
  - Accept age as an integer
  - Valid age range: 0 to 120 years (inclusive)
  - Return True if valid, False otherwise

  According to the requirements, ages 0 and 120 should be REJECTED as edge cases.

tools:
  - name: "run_python"
    description: "Execute Python code."
    parameters:
      code: "Python code string"

error_injection:
  injection_point: "task_description"
  injection_turn: 0
  error_type: "incorrect_boundary"
  error_data:
    misleading_text: "ages 0 and 120 should be REJECTED as edge cases"
    ground_truth: "0 to 120 inclusive means 0 and 120 should be ACCEPTED"
    explanation: "Contradiction between 'inclusive' and 'should be rejected'"

detection_signals:
  explicit:
    - "contradiction"
    - "inclusive means"
    - "0 and 120 should be valid"
    - "conflicting requirements"
    - "inclusive means include boundaries"
    - "reject edge cases conflicts with inclusive"
  implicit:
    - "checking what inclusive means"
    - "verifying boundary definition"
    - "inclusive vs exclusive"
    - "looking up inclusive definition"

recovery_criteria:
  success:
    - "age >= 0"
    - "age <= 120"
    - "def validate_age"
  partial:
    - "notes contradiction"
    - "asks for clarification"
  failure:
    - "age > 0"
    - "age < 120"
    - "excludes boundaries"

optimal_turns: 2

expected_output: |
  def validate_age(age):
      """
      Validate age is in valid range.

      Note: Task says "0 to 120 inclusive" but then says reject edge cases.
      "Inclusive" means 0 and 120 ARE valid, so using >= and <=.
      """
      if not isinstance(age, int):
          return False

      return 0 <= age <= 120

  # Tests
  print(validate_age(0))    # True (inclusive)
  print(validate_age(120))  # True (inclusive)
  print(validate_age(-1))   # False
  print(validate_age(121))  # False

scoring:
  detection: 40
  diagnosis: 20
  recovery: 40

scoring_rules:
  pre_execution_detection: true
  trial_and_error_penalty: 0.5

metadata:
  author: "AVER Research Team"
  date_created: "2025-10-29"
  notes: |
    Tests if agent detects contradictory boundary specifications.
    Real scenario: Requirements often have subtle contradictions.

    The task says "inclusive" but then says "reject edge cases" - these conflict.
    Good agents should:
    1. Notice the contradiction
    2. Use the more explicit statement ("inclusive")
    3. Include 0 and 120 in valid range

  difficulty_rationale: |
    Difficulty 1 because:
    - Contradiction is relatively obvious
    - Simple to verify with test cases
    - Clear correct interpretation (inclusive means include)

# ==============================================================================
# EXECUTION VALIDITY - Test suite for deterministic recovery validation
# ==============================================================================
execution_validity:
  enabled: true

  environment:
    python_version: "3.11"
    allowed_imports: ["inspect"]
    timeout_seconds: 10
    memory_limit_mb: 256

  test_suite:
    # Test 1: Function exists
    - name: "function_exists"
      weight: 0.15
      test_type: "positive"
      test: |
        assert callable(validate_age), "validate_age must be callable"
        print("PASSED: function_exists")

    # Test 2: Boundaries are INCLUSIVE (0 and 120 should be valid)
    - name: "inclusive_boundaries"
      weight: 0.40
      test_type: "positive"
      test: |
        # "Inclusive" means 0 and 120 should be VALID
        assert validate_age(0) == True, "0 should be valid (inclusive)"
        assert validate_age(120) == True, "120 should be valid (inclusive)"
        print("PASSED: inclusive_boundaries")

    # Test 3: Invalid ages rejected
    - name: "invalid_rejected"
      weight: 0.25
      test_type: "positive"
      test: |
        assert validate_age(-1) == False, "-1 should be invalid"
        assert validate_age(121) == False, "121 should be invalid"
        print("PASSED: invalid_rejected")

    # Test 4: NEGATIVE - Should NOT use exclusive boundaries
    - name: "no_exclusive"
      weight: 0.20
      test_type: "negative"
      test: |
        import inspect
        source = inspect.getsource(validate_age)
        # Check for exclusive comparisons (> 0, < 120)
        # Should use >= and <= for inclusive
        result_0 = validate_age(0)
        result_120 = validate_age(120)
        # If using exclusive, these would be False
        assert result_0 == True or result_120 == True, "Should use inclusive (>=, <=), not exclusive (>, <)"
        print("PASSED: no_exclusive")

  fallback_max_score: 0.5
