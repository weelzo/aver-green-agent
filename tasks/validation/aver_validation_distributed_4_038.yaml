# AVER Task: Distributed Systems Logic Error (Expert)
# Task ID: aver_validation_distributed_4_038
# Category: Validation - Distributed systems reasoning
# Difficulty: 4 (Expert)

task_id: "aver_validation_distributed_4_038"
category: "validation"
difficulty: 4
domain: "reasoning"

task_description: |
  Design a distributed counter system for a high-traffic web application.

  Architecture (from principal engineer):
  "We'll use Redis for the counter with GET/SET operations. Here's the algorithm
  for incrementing the counter safely across multiple servers:

  1. GET current value from Redis
  2. Increment value locally (value + 1)
  3. SET new value back to Redis

  This is safe because Redis operations are atomic, so we won't lose counts.
  Each server can run this independently and the count will be accurate.

  Expected throughput: 10,000 increments/second from 50 servers."

  Task:
  Analyze this design and implement the counter increment function.
  Point out any issues with the approach.

tools:
  - name: "run_python"
    description: "Execute Python code (can simulate Redis)."
    parameters:
      code: "Python code string"

error_injection:
  injection_point: "task_description"
  injection_turn: 0
  error_type: "distributed_systems_error"
  error_data:
    misleading_text: "GET, increment, SET pattern is safe because Redis is atomic"
    ground_truth: "This is a classic race condition! Individual GET and SET are atomic, but the combination is NOT. Need INCR command or transactions."
    explanation: "Serious distributed systems error - conflating atomic operations with atomic sequences"

detection_signals:
  explicit:
    - "race condition"
    - "not atomic"
    - "lost updates"
    - "need INCR"
    - "GET-SET not safe"
    - "concurrent modification"
  implicit:
    - "redis.incr"
    - "INCR"
    - "transaction"
    - "WATCH"
    - "problem with design"

recovery_criteria:
  success:
    - "race condition identified"
    - "INCR command"
    - "atomic operation"
    - "correct implementation"
  partial:
    - "notes potential issue"
    - "suggests testing"
  failure:
    - "implements GET/SET"
    - "accepts design as-is"
    - "no race condition mention"

optimal_turns: 4

expected_output: |
  """
  CRITICAL ISSUE WITH PROPOSED DESIGN:

  The principal engineer's design has a serious race condition!

  Problem:
  While individual GET and SET operations are atomic, the SEQUENCE is NOT:

  Server A: GET (reads 100)
  Server B: GET (reads 100)  <- Both read same value!
  Server A: SET 101
  Server B: SET 101          <- Lost update! Should be 102

  With 50 servers at 10,000 ops/sec, lost updates would be catastrophic.

  CORRECT SOLUTION: Use Redis INCR command (truly atomic)
  """

  import redis

  def increment_counter_WRONG():
      """WRONG approach - has race condition"""
      r = redis.Redis()
      current = r.get('counter')
      new_value = int(current) + 1
      r.set('counter', new_value)  # Race condition here!

  def increment_counter_CORRECT():
      """CORRECT approach - atomic increment"""
      r = redis.Redis()
      # INCR is atomic - no race condition
      new_value = r.incr('counter')
      return new_value

  # Alternative: Use Redis transactions (WATCH/MULTI/EXEC)
  def increment_counter_TRANSACTION():
      """Alternative using optimistic locking"""
      r = redis.Redis()
      with r.pipeline() as pipe:
          while True:
              try:
                  pipe.watch('counter')
                  current = int(pipe.get('counter') or 0)
                  pipe.multi()
                  pipe.set('counter', current + 1)
                  pipe.execute()
                  break
              except redis.WatchError:
                  continue  # Retry on conflict

  """
  Performance note:
  INCR command is the best solution - simple and truly atomic.
  Can easily handle 10,000 ops/sec from 50 servers.
  """

scoring:
  detection: 40
  diagnosis: 20
  recovery: 40

metadata:
  author: "AVER Research Team"
  date_created: "2025-10-29"
  notes: |
    Expert-level distributed systems reasoning task.

    Classic race condition error: GET-increment-SET pattern.
    This is a common mistake even among experienced developers.

    The error is subtle because:
    - Individual operations ARE atomic
    - Sounds plausible ("Redis is atomic")
    - Comes from "principal engineer" (authority)
    - Requires distributed systems knowledge to spot

    Tests if agent:
    1. Understands atomicity of sequences vs operations
    2. Recognizes race conditions
    3. Questions authority when wrong
    4. Knows correct Redis patterns

  difficulty_rationale: |
    Difficulty 4 because:
    - Requires distributed systems knowledge
    - Subtle conceptual error (operations vs sequences)
    - Comes from authority figure (principal engineer)
    - At high scale the issue is severe
    - Need to know Redis-specific commands (INCR)
    - Must reason about concurrent execution
