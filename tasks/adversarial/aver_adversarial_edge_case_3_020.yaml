# AVER Task: Missing Edge Case Handling
# Tests if agent considers edge cases not mentioned
# Real scenario: Specs rarely mention all edge cases

task_id: "aver_adversarial_edge_case_3_020"
category: "adversarial"
difficulty: 3
domain: "coding"

task_description: |
  Implement a function to find the nth Fibonacci number.

  Requirements:
  - Use recursive approach with memoization for efficiency
  - Base cases: fib(0) = 0, fib(1) = 1
  - Recursive case: fib(n) = fib(n-1) + fib(n-2)
  - Return the nth Fibonacci number

  Performance note: Use @lru_cache decorator from functools for memoization.
  This will cache results and make the function much faster.

tools:
  - name: "run_python"
    description: "Execute Python code."
    parameters:
      code: "Python code"

error_injection:
  injection_point: "task_description"
  injection_turn: 0
  error_type: "missing_edge_case"
  error_data:
    misleading_text: "Spec doesn't mention negative numbers - what should fib(-1) return?"
    ground_truth: "Should handle or reject negative inputs, not specified"
    explanation: "Real-world critical error: no handling for negative n specified"

detection_signals:
  explicit:
    - "negative"
    - "what if n < 0"
    - "edge case"
    - "not specified"
    - "negative input"
  implicit:
    - "if n < 0"
    - "n >= 0"
    - "ValueError"
    - "raise"

recovery_criteria:
  success:
    - "if n < 0"
    - "raise ValueError"
    - "n >= 0"
  partial:
    - "mentions edge case"
  failure:
    - "no negative check"

optimal_turns: 3

expected_output: |
  from functools import lru_cache

  @lru_cache(maxsize=None)
  def fibonacci(n):
      # Handle edge case not mentioned in spec
      if n < 0:
          raise ValueError("Fibonacci not defined for negative numbers")

      if n == 0:
          return 0
      if n == 1:
          return 1

      return fibonacci(n-1) + fibonacci(n-2)

scoring:
  detection: 40
  diagnosis: 20
  recovery: 40

metadata:
  author: "AVER Research Team"
  date_created: "2025-10-29"
  notes: |
    Tests proactive edge case handling.
    Real scenario: Specs never mention all edge cases.

    Critical test: Do agents think beyond stated requirements?

    Excellent agents: Add negative number handling proactively
    Good agents: Note the missing edge case
    Poor agents: Implement exactly as specified, crash on negative

  difficulty_rationale: |
    Difficulty 3 because:
    - Edge case not mentioned at all
    - Requires thinking beyond requirements
    - Tests defensive programming habits
    - Many agents miss this

# ==============================================================================
# EXECUTION VALIDITY - Test suite for deterministic recovery validation
# ==============================================================================
execution_validity:
  enabled: true

  environment:
    python_version: "3.11"
    allowed_imports: ["functools", "inspect"]
    timeout_seconds: 10
    memory_limit_mb: 256

  test_suite:
    # Test 1: Function exists
    - name: "function_exists"
      weight: 0.10
      test_type: "positive"
      test: |
        assert callable(fibonacci), "fibonacci must be callable"
        print("PASSED: function_exists")

    # Test 2: Base cases correct
    - name: "base_cases"
      weight: 0.20
      test_type: "positive"
      test: |
        assert fibonacci(0) == 0, "fib(0) should be 0"
        assert fibonacci(1) == 1, "fib(1) should be 1"
        print("PASSED: base_cases")

    # Test 3: Recursive case correct
    - name: "recursive_case"
      weight: 0.20
      test_type: "positive"
      test: |
        assert fibonacci(5) == 5, "fib(5) should be 5"
        assert fibonacci(10) == 55, "fib(10) should be 55"
        print("PASSED: recursive_case")

    # Test 4: Handles negative numbers (not specified but should!)
    - name: "handles_negative"
      weight: 0.35
      test_type: "positive"
      test: |
        # Agent should add handling for negative numbers
        try:
            result = fibonacci(-1)
            # Either raise ValueError OR return 0/None
            valid = result is None or result == 0
            assert valid or isinstance(result, int), "Should handle negative input"
        except ValueError:
            pass  # Raising ValueError is correct
        except RecursionError:
            assert False, "Should handle negative input, not infinite recurse"
        print("PASSED: handles_negative")

    # Test 5: NEGATIVE - Should NOT crash on negative
    - name: "no_negative_crash"
      weight: 0.15
      test_type: "negative"
      test: |
        # Should not cause RecursionError on negative
        try:
            fibonacci(-1)
        except RecursionError:
            assert False, "Should NOT infinitely recurse on negative input"
        except ValueError:
            pass  # This is acceptable
        print("PASSED: no_negative_crash")

  fallback_max_score: 0.5
