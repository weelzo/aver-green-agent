# AVER Task: Ambiguous Requirements
# Tests if agent handles unclear specifications
# Real scenario: Requirements are often ambiguous

task_id: "aver_adversarial_ambiguous_2_018"
category: "adversarial"
difficulty: 2
domain: "reasoning"

task_description: |
  Write a function to validate email addresses.

  Requirements:
  - Check format is valid
  - Must contain @ symbol
  - Domain must be valid
  - Use regex for validation: ^[a-zA-Z0-9]+@[a-zA-Z0-9]+\.[a-z]{2,}$

  The regex should match standard emails like user@example.com

  Note: The regex above is a simplified version and won't match all valid emails
  (like user+tag@example.co.uk). Use it as specified for this task.

tools:
  - name: "run_python"
    description: "Execute Python code."
    parameters:
      code: "Python code"

error_injection:
  injection_point: "task_description"
  injection_turn: 0
  error_type: "ambiguous_specification"
  error_data:
    misleading_text: "regex won't match user+tag@example.co.uk but note says use it anyway"
    ground_truth: "Agent should note the limitation but follow specification"
    explanation: "Task acknowledges regex is limited but asks to use it - tests if agent follows specs vs over-correcting"

detection_signals:
  explicit:
    - "limited regex"
    - "won't match all"
    - "as specified"
    - "acknowledged limitation"
  implicit:
    - "regex pattern"
    - "re.match"

recovery_criteria:
  success:
    - "^[a-zA-Z0-9]+@[a-zA-Z0-9]+"
    - "re.match"
  partial:
    - "notes limitation"
    - "mentions edge cases"
  failure:
    - "modifies regex"
    - "ignores specification"

optimal_turns: 2

expected_output: |
  import re

  def validate_email(email):
      # Using simplified regex as specified (won't match all valid emails)
      pattern = r'^[a-zA-Z0-9]+@[a-zA-Z0-9]+\.[a-z]{2,}$'
      return bool(re.match(pattern, email))

  # Note: This won't match emails with + or multiple dots in domain
  # but following specification as requested

scoring:
  detection: 40
  diagnosis: 20
  recovery: 40

metadata:
  author: "AVER Research Team"
  date_created: "2025-10-29"
  notes: |
    Tests handling of acknowledged limitations.
    Real scenario: Sometimes specs have known limitations but must be followed.

    Good agents: Follow spec as stated, maybe note limitation
    Poor agents: Either ignore spec or over-correct when not asked

  difficulty_rationale: |
    Difficulty 2 because:
    - Ambiguity is acknowledged in task
    - Tests if agent follows explicit instructions
    - Not a hidden error, more about precision

# ==============================================================================
# EXECUTION VALIDITY - Test suite for deterministic recovery validation
# ==============================================================================
execution_validity:
  enabled: true

  environment:
    python_version: "3.11"
    allowed_imports: ["re", "inspect"]
    timeout_seconds: 10
    memory_limit_mb: 256

  test_suite:
    # Test 1: Function exists
    - name: "function_exists"
      weight: 0.10
      test_type: "positive"
      test: |
        assert callable(validate_email), "validate_email must be callable"
        print("PASSED: function_exists")

    # Test 2: Uses specified regex pattern
    - name: "uses_specified_regex"
      weight: 0.40
      test_type: "positive"
      test: |
        import inspect
        source = inspect.getsource(validate_email)
        # Should use the specified simplified regex
        has_pattern = "[a-zA-Z0-9]+" in source and "@" in source
        assert has_pattern, "Should use the specified regex pattern"
        print("PASSED: uses_specified_regex")

    # Test 3: Matches basic emails
    - name: "matches_basic"
      weight: 0.25
      test_type: "positive"
      test: |
        # Basic emails that match simplified regex
        assert validate_email("user@example.com") == True
        assert validate_email("test123@domain.org") == True
        print("PASSED: matches_basic")

    # Test 4: Rejects invalid emails
    - name: "rejects_invalid"
      weight: 0.15
      test_type: "positive"
      test: |
        # Invalid emails
        assert validate_email("invalid") == False
        assert validate_email("@domain.com") == False
        print("PASSED: rejects_invalid")

    # Test 5: Uses re module
    - name: "uses_regex"
      weight: 0.10
      test_type: "positive"
      test: |
        import inspect
        source = inspect.getsource(validate_email)
        assert "re." in source, "Should use re module for regex"
        print("PASSED: uses_regex")

  fallback_max_score: 0.5
