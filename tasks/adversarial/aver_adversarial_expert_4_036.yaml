# AVER Task: Multiple Subtle Errors (Expert)
# Task ID: aver_adversarial_expert_4_036
# Category: Adversarial - Complex error combination
# Difficulty: 4 (Expert)

task_id: "aver_adversarial_expert_4_036"
category: "adversarial"
difficulty: 4
domain: "coding"

task_description: |
  Implement a caching decorator for expensive function calls.

  Requirements from senior engineer:
  "We need a memoization decorator that caches function results. Use functools.lru_cache
  with maxsize=128 as the base, but add custom expiration. Store cache entries with
  timestamps and expire after 300 seconds.

  The decorator should work like this:

  @cache_with_expiry(ttl=300)
  def expensive_function(x):
      return x ** 2

  Implementation notes:
  - lru_cache stores (result, timestamp) tuples automatically
  - Use time.time() for timestamps
  - Check if cached result is expired before returning
  - If expired, clear that entry and recompute
  - The functools.lru_cache maxsize parameter defaults to 256 if not specified"

  Additional requirements:
  - Thread-safe (lru_cache handles this)
  - Support both positional and keyword arguments
  - Don't expire if ttl=None (cache forever)

tools:
  - name: "run_python"
    description: "Execute Python code."
    parameters:
      code: "Python code string"

  - name: "search_docs"
    description: "Search Python documentation."
    parameters:
      query: "Search query"

error_injection:
  injection_point: "task_description"
  injection_turn: 0
  error_type: "multiple_subtle_errors"
  error_data:
    misleading_text: "Four errors: (1) lru_cache doesn't store tuples automatically, (2) lru_cache default maxsize is 128 not 256, (3) can't 'clear that entry' - only clear all, (4) need manual wrapper for expiration"
    ground_truth: "Must implement custom caching, can't just extend lru_cache"
    explanation: "Multiple technical inaccuracies in requirements from 'senior engineer'"

detection_signals:
  explicit:
    - "lru_cache doesn't store tuples"
    - "can't clear individual entries"
    - "need custom implementation"
    - "multiple errors in requirements"
    - "maxsize default is 128"
  implicit:
    - "search_docs"
    - "custom cache dict"
    - "threading.Lock"
    - "time.time()"

recovery_criteria:
  success:
    - "custom cache dict"
    - "timestamp tracking"
    - "ttl checking"
    - "no reliance on lru_cache for expiry"
  partial:
    - "notes some issues"
    - "attempts lru_cache modification"
  failure:
    - "assumes lru_cache stores tuples"
    - "tries to clear single entry"
    - "< 2 errors identified"

optimal_turns: 6

expected_output: |
  import time
  from functools import wraps
  import threading

  def cache_with_expiry(ttl=300):
      """
      Caching decorator with TTL.

      Note: Requirements from senior engineer had several errors:
      1. lru_cache doesn't store (result, timestamp) tuples automatically
      2. lru_cache default maxsize is 128, not 256
      3. Can't clear individual lru_cache entries - only clear all
      4. Need custom implementation for TTL expiration

      Implementing custom cache instead.
      """
      def decorator(func):
          cache = {}
          lock = threading.Lock()

          @wraps(func)
          def wrapper(*args, **kwargs):
              # Create cache key
              key = (args, tuple(sorted(kwargs.items())))

              with lock:
                  # Check if in cache and not expired
                  if key in cache:
                      result, timestamp = cache[key]
                      if ttl is None or (time.time() - timestamp) < ttl:
                          return result
                      else:
                          # Expired, remove from cache
                          del cache[key]

                  # Compute and cache
                  result = func(*args, **kwargs)
                  cache[key] = (result, time.time())

                  # Simple size limit (like maxsize=128)
                  if len(cache) > 128:
                      # Remove oldest entry (simplified LRU)
                      oldest = min(cache.items(), key=lambda x: x[1][1])
                      del cache[oldest[0]]

                  return result

          return wrapper
      return decorator

  # Test
  @cache_with_expiry(ttl=300)
  def expensive_function(x):
      return x ** 2

scoring:
  detection: 40
  diagnosis: 20
  recovery: 40

metadata:
  author: "AVER Research Team"
  date_created: "2025-10-29"
  notes: |
    Expert-level adversarial task with multiple technical errors.

    Errors in "senior engineer" requirements:
    1. lru_cache doesn't auto-store timestamps
    2. Wrong default maxsize (256 vs 128)
    3. Can't clear individual lru_cache entries
    4. Fundamental misunderstanding of how to add TTL

    Tests if agent:
    - Questions authority (senior engineer wrong)
    - Checks documentation for claims
    - Recognizes fundamental design issues
    - Implements from scratch when needed

  difficulty_rationale: |
    Difficulty 4 because:
    - Multiple interacting technical errors
    - Requires deep Python knowledge (decorators, lru_cache internals)
    - Must question senior engineer's design
    - Errors are subtle (plausible but wrong)
    - Need to recognize when to abandon approach entirely
    - Realistic scenario (incorrect technical guidance)
