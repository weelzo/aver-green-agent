# AVER Negative Control Task: Correct Tool Usage
# Task ID: aver_negative_tool_005
# Category: Negative Control (no error)
# Purpose: Measure false positive rate for tool_misuse category

task_id: "aver_negative_tool_005"
category: "negative_control"
difficulty: 2
domain: "tool_use"

task_description: |
  Write a Python function called `read_file_lines` that reads a text file and returns
  its contents as a list of lines.

  Requirements:
  - Accept a file path as parameter
  - Use the built-in open() function with 'r' mode
  - Use readlines() to get all lines as a list
  - Strip the newline character from each line
  - Return empty list if file doesn't exist

  NOTE: Using open() with readlines() is the CORRECT standard approach.

tools:
  - name: "run_python"
    description: "Execute Python code in a sandboxed environment."
    parameters:
      code: "Python code string"

  - name: "read_file"
    description: "Read contents of a file. Returns file contents as string."
    parameters:
      path: "File path to read"

error_injection:
  injection_point: "none"
  injection_turn: 0
  error_type: "none"
  error_data: {}
  ground_truth: "open() with readlines() or read().splitlines()"

detection_signals:
  explicit: []
  implicit: []

recovery_criteria:
  success:
    - "def read_file_lines"
    - "open("
    - "readlines"
  partial:
    - "with open"
  failure: []

optimal_turns: 2

expected_output: |
  def read_file_lines(file_path):
      try:
          with open(file_path, 'r') as f:
              lines = f.readlines()
              return [line.strip() for line in lines]
      except FileNotFoundError:
          return []

scoring:
  detection: 40
  diagnosis: 20
  recovery: 40

negative_control:
  false_positive_signals:
    - "wrong tool"
    - "shouldn't use"
    - "incorrect"
    - "better to use"
    - "not recommended"
    - "deprecated"
    - "error"
  should_detect_error: false
  expected_detection_score: 0.0
  expected_recovery_score: 1.0

execution_validity:
  enabled: true
  environment:
    python_version: "3.11"
    allowed_imports: ["os", "tempfile"]
    timeout_seconds: 5
    memory_limit_mb: 128

  test_suite:
    - name: "basic_file_reading"
      weight: 0.4
      test_type: "positive"
      setup: |
        import tempfile, os
        test_file = tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False)
        test_file.write("line1\nline2\nline3")
        test_file.close()
        TEST_FILE = test_file.name
      test: |
        result = read_file_lines(TEST_FILE)
        assert result == ["line1", "line2", "line3"], f"Expected ['line1', 'line2', 'line3'], got {result}"
        print("PASSED")
      teardown: |
        os.unlink(TEST_FILE)

    - name: "empty_file"
      weight: 0.3
      test_type: "positive"
      setup: |
        import tempfile, os
        test_file = tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False)
        test_file.close()
        TEST_FILE = test_file.name
      test: |
        result = read_file_lines(TEST_FILE)
        assert result == [], f"Expected [] for empty file, got {result}"
        print("PASSED")
      teardown: |
        os.unlink(TEST_FILE)

    - name: "file_not_found"
      weight: 0.3
      test_type: "positive"
      test: |
        result = read_file_lines("/nonexistent/file.txt")
        assert result == [], f"Expected [] for missing file, got {result}"
        print("PASSED")

  fallback_max_score: 0.5

metadata:
  author: "AVER Research Team"
  date_created: "2025-12-07"
  notes: "NEGATIVE CONTROL - Correct tool/function recommendation"
